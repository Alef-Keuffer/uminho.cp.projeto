\haddockmoduleheading{Solucoes}
\label{module:Solucoes}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module Solucoes (
    ExpAr(Un, N, X, Bin), BinOp(Product, Sum), UnOp(Negate, E),
    inExpAr, baseExpAr, cataExpAr, anaExpAr, hyloExpAr, expd, eval_exp,
    optmize_eval, sd, ad, (×), (×), (⊕), (∐), (∐), BinExp, UnExp,
    OutExpAr, Injective(to), outExpAr, recExpAr, g_eval_exp, clean,
    gopt, Dup, Bin, Un, bin_aux, un_aux, sd_gen, ad_gen,
    prop_in_out_idExpAr, prop_out_in_idExpAr, prop_sum_idr,
    prop_sum_idl, prop_product_idr, prop_product_idl, prop_e_id,
    prop_negate_id, prop_double_negate,
    prop_optimize_respects_semantics, prop_const_rule, prop_var_rule,
    prop_sum_rule, prop_product_rule, prop_e_rule, prop_negate_rule,
    prop_congruent, fib', f', catdef, oracle, prop_cat, loop, inic,
    prj, cat, linear1d, NPoint, OverTime, prop_calcLine_def,
    prop_bezier_sym, ℚ, toℚ, fromℚ, calcLine, calc_line', myZipWithM,
    mySequenceA, myZipWith, myZip, outZip, mySequenceA', deCasteljau,
    hyloAlgForm, prop_avg, avg, avg_aux, avgLTree, e', bezier2d,
    World(World, points, time), initW, tick, actions, scaleTime,
    bezier2dAtTime, bezier2dAt, thicCirc, ps, picture, animateBezier,
    runBezier, runBezierSym, main, run, (.=?=.), (.==>.), (.<==>.),
    (.==.), (.<=.), (.&&&.)
  ) where\end{verbatim}}
\haddockendheader

\section{Problemas}
\subsection{Problema 1}
\subsubsection{Código Fornecido}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data ExpAr a
\end{tabular}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{X} & \\
\haddockdecltt{|} & \haddockdecltt{N a} & \\
\haddockdecltt{|} & \haddockdecltt{Bin BinOp (ExpAr a) (ExpAr a)} & \\
\haddockdecltt{|} & \haddockdecltt{Un UnOp (ExpAr a)} & \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq a => Eq (ExpAr a)\\instance Show a => Show (ExpAr a)\\instance Arbitrary a => Arbitrary (ExpAr a)\\instance Injective (ExpAr a) (OutExpAr a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data BinOp
\end{tabular}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Sum} & \\
\haddockdecltt{|} & \haddockdecltt{Product} & \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq BinOp\\instance Show BinOp\\instance Arbitrary BinOp
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Num c => Injective BinOp ((c, c) -> c)
\end{tabular}]
{\haddockbegindoc
Check \href{#sym}{Symbol Interpretation}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Injective (ExpAr a) (OutExpAr a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data UnOp
\end{tabular}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Negate} & \\
\haddockdecltt{|} & \haddockdecltt{E} & \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Eq UnOp\\instance Show UnOp\\instance Arbitrary UnOp
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Floating c => Injective UnOp (c -> c)
\end{tabular}]
{\haddockbegindoc
Check \href{#sym}{Symbol Interpretation}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Injective (ExpAr a) (OutExpAr a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
inExpAr :: (b ∐ (a ∐ (BinExp a ∐ UnExp a))) -> ExpAr a
\end{tabular}]
{\haddockbegindoc
\haddocktt{\haddockid{inExpAr}} ≡ \haddocktt{\haddockid{const} X \haddockid{∐} \haddockid{N} \haddockid{∐} bin \haddockid{∐} (\haddockid{Un} \haddocktt{＾}) where bin (op, (a, b)) = \haddockid{Bin} op a b}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
baseExpAr :: (a -> b)\\\ \ \ \ \ \ \ \ \ \ \ \ \ -> (c -> d)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> (e -> f)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> (g -> h)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> (i -> j)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> (k -> l)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> (m -> n)\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> (a ∐ (c ∐ ((e × (g × i)) ∐ (k × m))))\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> b ∐ (d ∐ ((f × (h × j)) ∐ (l × n)))
\end{tabular}]
{\haddockbegindoc
\haddocktt{\haddockid{baseExpAr}} ≡ \haddocktt{f g h j k l z = f \haddockid{⊕} g \haddockid{⊕} h \haddockid{×} j \haddockid{×} k \haddockid{⊕} l × z}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
cataExpAr :: ((() ∐ (c ∐ ((BinOp × (e × e)) ∐ (UnOp × e)))) -> e) -> ExpAr c -> e
\end{tabular}]
\item[\begin{tabular}{@{}l}
anaExpAr :: (a -> b ∐ (c ∐ ((BinOp × (a × a)) ∐ (UnOp × a)))) -> a -> ExpAr c
\end{tabular}]
\item[\begin{tabular}{@{}l}
hyloExpAr :: ((() ∐ (c ∐ ((BinOp × (d × d)) ∐ (UnOp × d)))) -> d)\\\ \ \ \ \ \ \ \ \ \ \ \ \ -> (a -> b ∐ (c ∐ ((BinOp × (a × a)) ∐ (UnOp × a)))) -> a -> d
\end{tabular}]
\item[\begin{tabular}{@{}l}
expd :: Floating a => a -> a
\end{tabular}]
\item[\begin{tabular}{@{}l}
eval{\char '137}exp :: Floating a => a -> ExpAr a -> a
\end{tabular}]
\item[\begin{tabular}{@{}l}
optmize{\char '137}eval :: (Floating a, Eq a) => a -> ExpAr a -> a
\end{tabular}]
\item[\begin{tabular}{@{}l}
sd :: Floating a => ExpAr a -> ExpAr a
\end{tabular}]
\item[\begin{tabular}{@{}l}
ad :: Floating a => a -> ExpAr a -> a
\end{tabular}]
\end{haddockdesc}
\subsubsection{Solução}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type (×) a b = (a, b)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
(×) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
\end{tabular}]
{\haddockbegindoc
bimap for tuple\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
(⊕) :: (a -> b) -> (c -> d) -> (a ∐ c) -> b ∐ d
\end{tabular}]
{\haddockbegindoc
bimap for either\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type (∐) = Either
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
(∐) :: (a -> c) -> (b -> c) -> (a ∐ b) -> c
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type BinExp d = BinOp × (ExpAr d × ExpAr d)
\end{tabular}]
{\haddockbegindoc
≡ \haddocktt{\haddockid{BinOp} \haddockid{×} (\haddockid{ExpAr} d \haddockid{×} \haddockid{ExpAr} d)}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type UnExp d = UnOp × ExpAr d
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type OutExpAr a = () ∐ (a ∐ (BinExp a ∐ UnExp a))
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
class Injective a b where
\end{tabular}]
{\haddockbegindoc
\haddockpremethods{}\emph{Methods}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
to :: forall b1 a1. (b1 {\char '176} b, a1 {\char '176} a) => a -> b
\end{tabular}]
\end{haddockdesc}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Floating c => Injective UnOp (c -> c)
\end{tabular}]
{\haddockbegindoc
Check \href{#sym}{Symbol Interpretation}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Num c => Injective BinOp ((c, c) -> c)
\end{tabular}]
{\haddockbegindoc
Check \href{#sym}{Symbol Interpretation}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Injective (ExpAr a) (OutExpAr a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
outExpAr :: ExpAr a -> OutExpAr a
\end{tabular}]
\item[\begin{tabular}{@{}l}
recExpAr :: (a -> e)\\\ \ \ \ \ \ \ \ \ \ \ \ -> (b ∐ (c ∐ ((d × (a × a)) ∐ (g × a))))\\\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ -> b ∐ (c ∐ ((d × (e × e)) ∐ (g × e)))
\end{tabular}]
\end{haddockdesc}

 Read this as the "interpretation" of each \haddockid{BinOp} symbol.\par
For example, the symbol \haddockid{Sum} is interperted as the function \haddockid{add}\par
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
g{\char '137}eval{\char '137}exp :: Floating c => c -> (b ∐ (c ∐ ((BinOp × (c × c)) ∐ (UnOp × c)))) -> c
\end{tabular}]
\item[\begin{tabular}{@{}l}
clean :: (Eq a, Num a) => ExpAr a -> OutExpAr a
\end{tabular}]
\item[\begin{tabular}{@{}l}
gopt :: Floating a => a -> (() ∐ (a ∐ ((BinOp × (a × a)) ∐ (UnOp × a)))) -> a
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Dup d = d × d
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Bin d = BinOp × (d × d)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Un d = UnOp × d
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
bin{\char '137}aux :: (t -> t -> t) -> (t -> t -> t) -> (BinOp, Dup (Dup t)) -> Dup t
\end{tabular}]
\item[\begin{tabular}{@{}l}
un{\char '137}aux :: (t1 -> t2) -> (t2 -> t1 -> t2) -> (t1 -> t2) -> (UnOp, Dup t1) -> Dup t2
\end{tabular}]
\item[\begin{tabular}{@{}l}
sd{\char '137}gen :: Floating a =>\\\ \ \ \ \ \ \ \ \ \ (() ∐ (a ∐ (Bin (Dup (ExpAr a)) ∐ Un (Dup (ExpAr a))))) -> Dup (ExpAr a)
\end{tabular}]
\item[\begin{tabular}{@{}l}
ad{\char '137}gen :: Floating a => a -> (() ∐ (a ∐ ((BinOp, Dup (Dup a)) ∐ (UnOp, Dup a)))) -> Dup a
\end{tabular}]
\end{haddockdesc}
\subsubsection{Propriedades}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
prop{\char '137}in{\char '137}out{\char '137}idExpAr :: Eq a => ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}out{\char '137}in{\char '137}idExpAr :: Eq a => OutExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}sum{\char '137}idr :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}sum{\char '137}idl :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}product{\char '137}idr :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}product{\char '137}idl :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}e{\char '137}id :: (Floating a, Real a) => a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}negate{\char '137}id :: (Floating a, Real a) => a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}double{\char '137}negate :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}optimize{\char '137}respects{\char '137}semantics :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}const{\char '137}rule :: (Real a, Floating a) => a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}var{\char '137}rule :: Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}sum{\char '137}rule :: (Real a, Floating a) => ExpAr a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}product{\char '137}rule :: (Real a, Floating a) => ExpAr a -> ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}e{\char '137}rule :: (Real a, Floating a) => ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}negate{\char '137}rule :: (Real a, Floating a) => ExpAr a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}congruent :: (Floating a, Real a) => a -> ExpAr a -> Bool
\end{tabular}]
\end{haddockdesc}
\subsection{Problema 2}
\subsubsection{Código Fornecido}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
fib' :: (Integral c, Num b) => c -> b
\end{tabular}]
\item[\begin{tabular}{@{}l}
f' :: (Integral c, Num b) => b -> b -> b -> c -> b
\end{tabular}]
\item[\begin{tabular}{@{}l}
catdef :: Integer -> Integer
\end{tabular}]
\item[\begin{tabular}{@{}l}
oracle :: Num a => {\char 91}a{\char 93}
\end{tabular}]
\end{haddockdesc}
\subsubsection{Propriedades}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
prop{\char '137}cat :: Integer -> Property
\end{tabular}]
\end{haddockdesc}
\subsubsection{Solução}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
loop :: Integral c => (c, c, c) -> (c, c, c)
\end{tabular}]
\item[\begin{tabular}{@{}l}
inic :: (Num a, Num b, Num c) => (a, b, c)
\end{tabular}]
\item[\begin{tabular}{@{}l}
prj :: (a, b, c) -> a
\end{tabular}]
\item[\begin{tabular}{@{}l}
cat :: (Integral c1, Integral c2) => c1 -> c2
\end{tabular}]
\end{haddockdesc}
\subsection{Problema 3}
\subsubsection{Código Fornecido}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
linear1d :: Rational -> Rational -> OverTime Rational
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type NPoint = {\char 91}Rational{\char 93}
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type OverTime a = Float -> a
\end{tabular}]
\end{haddockdesc}
\subsubsection{Propriedades}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
prop{\char '137}calcLine{\char '137}def :: NPoint -> NPoint -> Float -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
prop{\char '137}bezier{\char '137}sym :: {\char 91}{\char 91}Rational{\char 93}{\char 93} -> Gen Bool
\end{tabular}]
\end{haddockdesc}
\subsubsection{Solução}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type ℚ = Rational
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
toℚ :: Real a => a -> Rational
\end{tabular}]
\item[\begin{tabular}{@{}l}
fromℚ :: Fractional a => Rational -> a
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
calcLine :: NPoint -> NPoint -> OverTime NPoint
\end{tabular}]
{\haddockbegindoc
Spec\par
\begin{quote}
{\haddockverb\begin{verbatim}
calcLine :: NPoint -> (NPoint -> OverTime NPoint)
calcLine [] = const nil
calcLine (p : x) = curry g p (calcLine x)
 where
  g :: (ℚ, NPoint -> OverTime NPoint) -> (NPoint -> OverTime NPoint)
  g (d, f) l = case l of
    [] -> nil
    (x : xs) -> concat . sequenceA [singl . linear1d d x, f xs]
\end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
calc{\char '137}line' :: {\char 91}ℚ{\char 93} -> {\char 91}ℚ{\char 93} -> Float -> {\char 91}ℚ{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
myZipWithM :: (a1 -> b -> p -> a2) -> {\char 91}a1{\char 93} -> {\char 91}b{\char 93} -> p -> {\char 91}a2{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
mySequenceA :: {\char 91}p -> a{\char 93} -> p -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
myZipWith :: (a -> b -> c) -> {\char 91}a{\char 93} -> {\char 91}b{\char 93} -> {\char 91}c{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
myZip :: ({\char 91}a{\char 93}, {\char 91}b{\char 93}) -> {\char 91}(a, b){\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
outZip :: ({\char 91}a{\char 93}, {\char 91}b{\char 93}) -> () ∐ ((a, b), ({\char 91}a{\char 93}, {\char 91}b{\char 93}))
\end{tabular}]
\item[\begin{tabular}{@{}l}
mySequenceA' :: p -> {\char 91}p -> a{\char 93} -> {\char 91}a{\char 93}
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
deCasteljau :: {\char 91}NPoint{\char 93} -> OverTime NPoint
\end{tabular}]
{\haddockbegindoc
Spec\par
\begin{quote}
{\haddockverb\begin{verbatim}
deCasteljau :: [NPoint] -> OverTime NPoint
deCasteljau [] = nil
deCasteljau [p] = const p
deCasteljau l = pt -> calcLine (p pt) (q pt) pt
 where
  p = deCasteljau (init l)
  q = deCasteljau (tail l)
 \end{verbatim}}
\end{quote}}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
hyloAlgForm :: a
\end{tabular}]
\end{haddockdesc}
\subsection{Problema 4}
\subsubsection{Propriedades}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
prop{\char '137}avg :: (Ord b, Fractional b) => {\char 91}b{\char 93} -> Property
\end{tabular}]
\item[\begin{tabular}{@{}l}
avg :: Fractional b => {\char 91}b{\char 93} -> b
\end{tabular}]
\end{haddockdesc}
\subsubsection{Solução}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
avg{\char '137}aux :: Fractional b => {\char 91}b{\char 93} -> (b, b)
\end{tabular}]
\item[\begin{tabular}{@{}l}
avgLTree :: LTree b -> c
\end{tabular}]
\end{haddockdesc}
\section{Programação dinâmica por recursividade múltipla}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
e' :: (Fractional c1, Integral c2) => c1 -> c2 -> c1
\end{tabular}]
\end{haddockdesc}
\section{Código Extra para Problema 3}
\subsection{2D}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
bezier2d :: {\char 91}NPoint{\char 93} -> OverTime (Float, Float)
\end{tabular}]
\end{haddockdesc}
\subsection{Modelo}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data World
\end{tabular}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{World} & \\
                                            & \haddocktt{\qquad \{} \haddockdecltt{points :: {\char 91}NPoint{\char 93}} & \\
                                            & \haddocktt{\qquad ,} \haddockdecltt{time :: Float} & \\ & \haddocktt{\qquad \}} \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
initW :: World
\end{tabular}]
\item[\begin{tabular}{@{}l}
tick :: Float -> World -> World
\end{tabular}]
\item[\begin{tabular}{@{}l}
actions :: Event -> World -> World
\end{tabular}]
\item[\begin{tabular}{@{}l}
scaleTime :: World -> Float
\end{tabular}]
\item[\begin{tabular}{@{}l}
bezier2dAtTime :: World -> (Float, Float)
\end{tabular}]
\item[\begin{tabular}{@{}l}
bezier2dAt :: World -> OverTime (Float, Float)
\end{tabular}]
\item[\begin{tabular}{@{}l}
thicCirc :: Picture
\end{tabular}]
\item[\begin{tabular}{@{}l}
ps :: {\char 91}Float{\char 93}
\end{tabular}]
\end{haddockdesc}
\subsection{Gloss}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
picture :: World -> Picture
\end{tabular}]
\end{haddockdesc}
\subsection{Animação}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
animateBezier :: Float -> {\char 91}NPoint{\char 93} -> Picture
\end{tabular}]
\end{haddockdesc}
\subsection{Propriedades e main}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
runBezier :: IO ()
\end{tabular}]
\item[\begin{tabular}{@{}l}
runBezierSym :: IO ()
\end{tabular}]
\end{haddockdesc}
\subsubsection{Compilação e execução dentro do interpretador}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
main :: IO ()
\end{tabular}]
\item[\begin{tabular}{@{}l}
run :: IO ExitCode
\end{tabular}]
\end{haddockdesc}
\section{QuickCheck}
\section{Outras funções auxiliares}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
(.=?=.) :: Real a => a -> a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
(.==>.) :: Testable prop => (a -> Bool) -> (a -> prop) -> a -> Property
\end{tabular}]
\item[\begin{tabular}{@{}l}
(.<==>.) :: (a -> Bool) -> (a -> Bool) -> a -> Property
\end{tabular}]
\item[\begin{tabular}{@{}l}
(.==.) :: Eq b => (a -> b) -> (a -> b) -> a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
(.<=.) :: Ord b => (a -> b) -> (a -> b) -> a -> Bool
\end{tabular}]
\item[\begin{tabular}{@{}l}
(.{\char '46}{\char '46}{\char '46}.) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
\end{tabular}]
\end{haddockdesc}