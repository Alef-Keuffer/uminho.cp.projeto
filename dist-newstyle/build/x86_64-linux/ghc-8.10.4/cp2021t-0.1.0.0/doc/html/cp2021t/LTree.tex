\haddockmoduleheading{LTree}
\label{module:LTree}
\haddockbeginheader
{\haddockverb\begin{verbatim}
module LTree (
    LTree(Fork, Leaf), inLTree, outLTree, recLTree, baseLTree,
    cataLTree, anaLTree, hyloLTree, invLTree, countLTree, tips, dfac,
    dfacd, dsq', dsq, fib, fibd, mSort, merge, lsplit, dmap, dmap1, mu,
    tnat, monLTree, tips', countLTree', dlLTree, Deriv(Dr), Zipper,
    plug
  ) where\end{verbatim}}
\haddockendheader

\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data LTree a
\end{tabular}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Leaf a} & \\
\haddockdecltt{|} & \haddockdecltt{Fork (LTree a, LTree a)} & \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
instance Monad LTree\\instance Functor LTree\\instance Applicative LTree\\instance Strong LTree\\instance Eq a => Eq (LTree a)\\instance Show a => Show (LTree a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
inLTree :: Either a (LTree a, LTree a) -> LTree a
\end{tabular}]
\item[\begin{tabular}{@{}l}
outLTree :: LTree a -> Either a (LTree a, LTree a)
\end{tabular}]
\item[\begin{tabular}{@{}l}
recLTree :: (a -> d) -> Either b (a, a) -> Either b (d, d)
\end{tabular}]
\item[\begin{tabular}{@{}l}
baseLTree :: (a1 -> b) -> (a2 -> d) -> Either a1 (a2, a2) -> Either b (d, d)
\end{tabular}]
\item[\begin{tabular}{@{}l}
cataLTree :: (Either b (d, d) -> d) -> LTree b -> d
\end{tabular}]
\item[\begin{tabular}{@{}l}
anaLTree :: (a1 -> Either a2 (a1, a1)) -> a1 -> LTree a2
\end{tabular}]
\item[\begin{tabular}{@{}l}
hyloLTree :: (Either b (c, c) -> c) -> (a -> Either b (a, a)) -> a -> c
\end{tabular}]
\item[\begin{tabular}{@{}l}
invLTree :: LTree a -> LTree a
\end{tabular}]
\item[\begin{tabular}{@{}l}
countLTree :: LTree b -> Integer
\end{tabular}]
\item[\begin{tabular}{@{}l}
tips :: LTree a -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
dfac :: Integral p => p -> p
\end{tabular}]
\item[\begin{tabular}{@{}l}
dfacd :: Integral b => (b, b) -> Either b ((b, b), (b, b))
\end{tabular}]
\item[\begin{tabular}{@{}l}
dsq' :: Integer -> Integer
\end{tabular}]
\item[\begin{tabular}{@{}l}
dsq :: Integer -> Integer
\end{tabular}]
\item[\begin{tabular}{@{}l}
fib :: Integer -> Integer
\end{tabular}]
\item[\begin{tabular}{@{}l}
fibd :: (Ord b, Num b) => b -> Either () (b, b)
\end{tabular}]
\item[\begin{tabular}{@{}l}
mSort :: Ord a => {\char 91}a{\char 93} -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
merge :: Ord a => ({\char 91}a{\char 93}, {\char 91}a{\char 93}) -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
lsplit :: {\char 91}a{\char 93} -> Either a ({\char 91}a{\char 93}, {\char 91}a{\char 93})
\end{tabular}]
\item[\begin{tabular}{@{}l}
dmap :: (b -> a) -> {\char 91}b{\char 93} -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
dmap1 :: (b -> a) -> {\char 91}b{\char 93} -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
mu :: LTree (LTree a) -> LTree a
\end{tabular}]
\item[\begin{tabular}{@{}l}
tnat :: Monoid c => (a -> c) -> Either a (c, c) -> c
\end{tabular}]
\item[\begin{tabular}{@{}l}
monLTree :: Monoid d => (a -> d) -> LTree a -> d
\end{tabular}]
\item[\begin{tabular}{@{}l}
tips' :: LTree a -> {\char 91}a{\char 93}
\end{tabular}]
\item[\begin{tabular}{@{}l}
countLTree' :: LTree b -> Sum Integer
\end{tabular}]
\item[\begin{tabular}{@{}l}
dlLTree :: Strong f => LTree (f a) -> f (LTree a)
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
data Deriv a
\end{tabular}]
{\haddockbegindoc
\enspace \emph{Constructors}\par
\haddockbeginconstrs
\haddockdecltt{=} & \haddockdecltt{Dr Bool (LTree a)} & \\
\end{tabulary}\par}
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
type Zipper a = {\char 91}Deriv a{\char 93}
\end{tabular}]
\end{haddockdesc}
\begin{haddockdesc}
\item[\begin{tabular}{@{}l}
plug :: Zipper a -> LTree a -> LTree a
\end{tabular}]
\end{haddockdesc}