-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Trabalho para Calculo Proposicional da Universidade do Minho
--   
--   Trabalho para Calculo Proposicional da Universidade do Minho
@package cp2021t
@version 0.1.0.0

module Cp
split :: (a -> b) -> (a -> c) -> a -> (b, c)
(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
infix 5 ><
(!) :: a -> ()
p1 :: (a, b) -> a
p2 :: (a, b) -> b
i1 :: a -> Either a b
i2 :: b -> Either a b
(-|-) :: (a -> b) -> (c -> d) -> Either a c -> Either b d
infix 4 -|-
cond :: (b -> Bool) -> (b -> c) -> (b -> c) -> b -> c
ap :: (a -> b, a) -> b
expn :: (b -> c) -> (a -> b) -> a -> c
p2p :: (a, a) -> Bool -> a
grd :: (a -> Bool) -> a -> Either a a
swap :: (a, b) -> (b, a)
assocr :: ((a, b), c) -> (a, (b, c))
assocl :: (a, (b, c)) -> ((a, b), c)
undistr :: Either (a, b) (a, c) -> (a, Either b c)
undistl :: Either (b, c) (a, c) -> (Either b a, c)
flatr :: (a, (b, c)) -> (a, b, c)
flatl :: ((a, b), c) -> (a, b, c)
br :: a -> (a, ())
bl :: a -> ((), a)
coswap :: Either a b -> Either b a
coassocr :: Either (Either a b) c -> Either a (Either b c)
coassocl :: Either b (Either a c) -> Either (Either b a) c
distl :: (Either c a, b) -> Either (c, b) (a, b)
distr :: (b, Either c a) -> Either (b, c) (b, a)
class BiFunctor f
bmap :: BiFunctor f => (a -> b) -> (c -> d) -> f a c -> f b d
(.!) :: Monad a => (b -> a c) -> (d -> a b) -> d -> a c
infix 4 .!
mult :: Monad m => m (m b) -> m b
ap' :: Monad m => (a -> m b, m a) -> m b
singl :: a -> [a]
class (Functor f, Monad f) => Strong f
rstr :: Strong f => (f a, b) -> f (a, b)
lstr :: Strong f => (b, f a) -> f (b, a)
dstr :: Strong m => (m a, m b) -> m (a, b)
splitm :: Strong ff => ff (a -> b) -> a -> ff b
bang :: a -> ()
dup :: c -> (c, c)
zero :: b -> Integer
one :: b -> Integer
nil :: b -> [a]
cons :: (a, [a]) -> [a]
add :: (Integer, Integer) -> Integer
mul :: (Integer, Integer) -> Integer
conc :: ([a], [a]) -> [a]
true :: b -> Bool
nothing :: b -> Maybe a
false :: b -> Bool
inMaybe :: Either () a -> Maybe a
class (Functor f) => Unzipable f
unzp :: Unzipable f => f (a, b) -> (f a, f b)
class Functor g => DistL g
lamb :: (DistL g, Monad m) => g (m a) -> m (g a)
aap :: Monad m => m (a -> b) -> m a -> m b
gather :: [a -> b] -> a -> [b]
cozip :: Functor f => Either (f a) (f b) -> f (Either a b)
tot :: (a -> b) -> (a -> Bool) -> a -> Maybe b
instance Cp.DistL []
instance Cp.DistL GHC.Maybe.Maybe
instance Cp.Strong GHC.Types.IO
instance Cp.Strong []
instance Cp.Strong GHC.Maybe.Maybe
instance Cp.BiFunctor Data.Either.Either
instance Cp.BiFunctor (,)

module BTree
data BTree a
Empty :: BTree a
Node :: (a, (BTree a, BTree a)) -> BTree a
inBTree :: Either () (b, (BTree b, BTree b)) -> BTree b
outBTree :: BTree a -> Either () (a, (BTree a, BTree a))
recBTree :: (a -> d) -> Either b1 (b2, (a, a)) -> Either b1 (b2, (d, d))
cataBTree :: (Either () (b, (d, d)) -> d) -> BTree b -> d
anaBTree :: (a -> Either () (b, (a, a))) -> a -> BTree b
hyloBTree :: (Either () (b, (c, c)) -> c) -> (a -> Either () (b, (a, a))) -> a -> c
baseBTree :: (a1 -> b1) -> (a2 -> d) -> Either b2 (a1, (a2, a2)) -> Either b2 (b1, (d, d))
invBTree :: BTree b -> BTree b
countBTree :: BTree a -> Integer
inordt :: BTree a -> [a]
inord :: Either b (a, ([a], [a])) -> [a]
preordt :: BTree a -> [a]
preord :: Either b (a, ([a], [a])) -> [a]
postordt :: BTree a -> [a]
qSort :: Ord a => [a] -> [a]
qsep :: Ord a => [a] -> Either () (a, ([a], [a]))
part :: (a -> Bool) -> [a] -> ([a], [a])
traces :: Eq a => BTree a -> [[a]]
tunion :: Eq a => (a, ([[a]], [[a]])) -> [[a]]
hanoi :: (Bool, Integer) -> [(Integer, Bool)]
present :: Either b (a, ([a], [a])) -> [a]
strategy :: Integral b => (Bool, b) -> Either () ((b, Bool), ((Bool, b), (Bool, b)))
balBTree :: BTree a -> Bool
depthBTree :: BTree a -> Integer
baldepth :: BTree a -> (Bool, Integer)
tnat :: Monoid c => (a -> c) -> Either () (a, (c, c)) -> c
monBTree :: Monoid d => (a -> d) -> BTree a -> d
preordt' :: BTree a -> [a]
countBTree' :: BTree b -> Sum Integer
data Deriv a
Dr :: Bool -> a -> BTree a -> Deriv a
type Zipper a = [Deriv a]
plug :: Zipper a -> BTree a -> BTree a
instance GHC.Show.Show a => GHC.Show.Show (BTree.BTree a)
instance GHC.Base.Functor BTree.BTree

module Nat
inNat :: Either b Integer -> Integer
outNat :: Integral b => b -> Either () b
cataNat :: Integral c => (Either () d -> d) -> c -> d
recNat :: (c -> d) -> Either b c -> Either b d
anaNat :: (c -> Either b c) -> c -> Integer
hyloNat :: (Either () c1 -> c1) -> (c2 -> Either b c2) -> c2 -> c1
for :: Integral c => (b -> b) -> b -> c -> b
somar :: (Integral c, Enum d) => d -> c -> d
multip :: (Integral c, Num d) => d -> c -> d
exp :: (Integral c, Num d) => d -> c -> d
sq :: Integral p => p -> p
sq' :: Integer -> Integer
sq'' :: (Integral c, Num b) => c -> b
fac :: Integer -> Integer
facfor :: Integer -> (Integer, Integer)
idiv :: Integer -> Integer -> Integer
aux :: (Ord c, Num c) => c -> c -> Integer
bSort :: Ord a => [a] -> [a]
while :: (a -> Bool) -> (a -> a) -> a -> a
mfor :: forall t1 m t2. (Monad m, Integral t1) => (t2 -> m t2) -> t2 -> t1 -> m t2

module List
inList :: Either b (a, [a]) -> [a]
outList :: [a] -> Either () (a, [a])
cataList :: (Either () (b, d) -> d) -> [b] -> d
recList :: (c -> d) -> Either b1 (b2, c) -> Either b1 (b2, d)
anaList :: (c -> Either b (a, c)) -> c -> [a]
hyloList :: (Either () (b1, c1) -> c1) -> (c2 -> Either b2 (b1, c2)) -> c2 -> c1
baseList :: (a -> b1) -> (c -> d) -> Either b2 (a, c) -> Either b2 (b1, d)
eval :: Integer -> [Integer] -> Integer
invl :: [a] -> [a]
look :: Eq a => a -> [(a, b)] -> Maybe b
iSort :: Ord a => [a] -> [a]
take' :: Integer -> [a] -> [a]
fac :: Integer -> Integer
algMul :: Either b (Integer, Integer) -> Integer
nats :: Integer -> Either () (Integer, Integer)
fac' :: Integer -> Integer
sq :: Integer -> Integer
summing :: Either b (Integer, Integer) -> Integer
odds :: Integer -> Either () (Integer, Integer)
sq' :: Integer -> Integer
prefixes :: Eq a => [a] -> [[a]]
suffixes :: [a] -> [[a]]
diff :: Eq a => [a] -> [a] -> [a]
nest :: Eq a => Int -> [a] -> [[a]]
myfoldr :: (a -> b -> b) -> b -> [a] -> b
myfoldl :: (a -> b -> a) -> a -> [b] -> a
nr :: Eq a => [a] -> Bool
ccat :: [a] -> [a] -> [a]
mmap :: Strong m => (a1 -> m a2) -> [a1] -> m [a2]
lam :: Strong m => [m a] -> m [a]
mcataList :: Strong ff => (Either () (b, c) -> ff c) -> [b] -> ff c
dl :: Strong m => Either () (b, m a) -> m (Either () (b, a))
stream :: (t1 -> Maybe (a, t1)) -> (t1 -> t2 -> t1) -> t1 -> [t2] -> [a]
join :: ([a], [b]) -> [Either a b]
sep :: [Either a1 a2] -> ([a1], [a2])

module LTree
data LTree a
Leaf :: a -> LTree a
Fork :: (LTree a, LTree a) -> LTree a
inLTree :: Either a (LTree a, LTree a) -> LTree a
outLTree :: LTree a -> Either a (LTree a, LTree a)
recLTree :: (a -> d) -> Either b (a, a) -> Either b (d, d)
baseLTree :: (a1 -> b) -> (a2 -> d) -> Either a1 (a2, a2) -> Either b (d, d)
cataLTree :: (Either b (d, d) -> d) -> LTree b -> d
anaLTree :: (a1 -> Either a2 (a1, a1)) -> a1 -> LTree a2
hyloLTree :: (Either b (c, c) -> c) -> (a -> Either b (a, a)) -> a -> c
invLTree :: LTree a -> LTree a
countLTree :: LTree b -> Integer
tips :: LTree a -> [a]
dfac :: Integral p => p -> p
dfacd :: Integral b => (b, b) -> Either b ((b, b), (b, b))
dsq' :: Integer -> Integer
dsq :: Integer -> Integer
fib :: Integer -> Integer
fibd :: (Ord b, Num b) => b -> Either () (b, b)
mSort :: Ord a => [a] -> [a]
merge :: Ord a => ([a], [a]) -> [a]
lsplit :: [a] -> Either a ([a], [a])
dmap :: (b -> a) -> [b] -> [a]
dmap1 :: (b -> a) -> [b] -> [a]
mu :: LTree (LTree a) -> LTree a
tnat :: Monoid c => (a -> c) -> Either a (c, c) -> c
monLTree :: Monoid d => (a -> d) -> LTree a -> d
tips' :: LTree a -> [a]
countLTree' :: LTree b -> Sum Integer
dlLTree :: Strong f => LTree (f a) -> f (LTree a)
data Deriv a
Dr :: Bool -> LTree a -> Deriv a
type Zipper a = [Deriv a]
plug :: Zipper a -> LTree a -> LTree a
instance GHC.Classes.Eq a => GHC.Classes.Eq (LTree.LTree a)
instance GHC.Show.Show a => GHC.Show.Show (LTree.LTree a)
instance GHC.Base.Functor LTree.LTree
instance GHC.Base.Monad LTree.LTree
instance Cp.Strong LTree.LTree
instance GHC.Base.Applicative LTree.LTree

module Main

-- | <h2>Problema 1</h2>
data ExpAr a
X :: ExpAr a
N :: a -> ExpAr a
Bin :: BinOp -> ExpAr a -> ExpAr a -> ExpAr a
Un :: UnOp -> ExpAr a -> ExpAr a
data BinOp
Sum :: BinOp
Product :: BinOp
data UnOp
Negate :: UnOp
E :: UnOp
inExpAr :: Either b (Either a (Either (BinOp, (ExpAr a, ExpAr a)) (UnOp, ExpAr a))) -> ExpAr a
baseExpAr :: (a1 -> b1) -> (a2 -> b2) -> (a3 -> b3) -> (a4 -> b4) -> (c1 -> d1) -> (a5 -> b5) -> (c2 -> d2) -> Either a1 (Either a2 (Either (a3, (a4, c1)) (a5, c2))) -> Either b1 (Either b2 (Either (b3, (b4, d1)) (b5, d2)))
prop_in_out_idExpAr :: Eq a => ExpAr a -> Bool
prop_out_in_idExpAr :: Eq a => OutExpAr a -> Bool
prop_sum_idr :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_sum_idl :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_product_idr :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_product_idl :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_e_id :: (Floating a, Real a) => a -> Bool
prop_negate_id :: (Floating a, Real a) => a -> Bool
prop_double_negate :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_optimize_respects_semantics :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_const_rule :: (Real a, Floating a) => a -> Bool
prop_var_rule :: Bool
prop_sum_rule :: (Real a, Floating a) => ExpAr a -> ExpAr a -> Bool
prop_product_rule :: (Real a, Floating a) => ExpAr a -> ExpAr a -> Bool
prop_e_rule :: (Real a, Floating a) => ExpAr a -> Bool
prop_negate_rule :: (Real a, Floating a) => ExpAr a -> Bool
prop_congruent :: (Floating a, Real a) => a -> ExpAr a -> Bool

-- | <h2>Problema 2</h2>
fib' :: Integer -> Integer
f' :: (Integral c, Num b) => b -> b -> b -> c -> b
prop_cat :: Integer -> Property

-- | <h2>Problema 3</h2>
linear1d :: Rational -> Rational -> OverTime Rational
type NPoint = [Rational]
type OverTime a = Float -> a
prop_calcLine_def :: NPoint -> NPoint -> Float -> Bool
prop_bezier_sym :: [[Rational]] -> Gen Bool

-- | <h2>Problema 4</h2>
prop_avg :: [Double] -> Property

-- | <h1>Programação dinâmica por recursividade múltipla</h1>
e' :: (Integral c1, Fractional c2) => c2 -> c1 -> c2

-- | <h1>Código Fornecido</h1>
--   
--   <h2>Problema 1</h2>
type OutExpAr a = Either () (Either a (Either (BinOp, (ExpAr a, ExpAr a)) (UnOp, ExpAr a)))
expd :: Floating a => a -> a

-- | <h2>Problema 2</h2>
catdef :: Integer -> Integer
oracle :: [Integer]

-- | <h2>Problema 3</h2>
--   
--   <h3>2D</h3>
bezier2d :: [NPoint] -> OverTime (Float, Float)

-- | <h3>Modelo</h3>
data World
World :: [NPoint] -> Float -> World
[points] :: World -> [NPoint]
[time] :: World -> Float
initW :: World
tick :: Float -> World -> World
actions :: Event -> World -> World
scaleTime :: World -> Float
bezier2dAtTime :: World -> (Float, Float)
bezier2dAt :: World -> OverTime (Float, Float)
thicCirc :: Picture
ps :: [Float]

-- | <h3>Gloss</h3>
picture :: World -> Picture

-- | <h3>Animação</h3>
animateBezier :: Float -> [NPoint] -> Picture

-- | <h3>Propriedades e main</h3>
runBezier :: IO ()
runBezierSym :: IO ()

-- | <h4>Compilação e execução dentro do interpretador</h4>
main :: IO ()
run :: IO ExitCode

-- | <h2>Outras funções auxiliares</h2>
(.=?=.) :: Real a => a -> a -> Bool
infixr 5 .=?=.
(.==>.) :: Testable prop => (a -> Bool) -> (a -> prop) -> a -> Property
infixr 0 .==>.
(.<==>.) :: (a -> Bool) -> (a -> Bool) -> a -> Property
infixr 0 .<==>.
(.==.) :: Eq b => (a -> b) -> (a -> b) -> a -> Bool
infixr 4 .==.
(.<=.) :: Ord b => (a -> b) -> (a -> b) -> a -> Bool
infixr 4 .<=.
(.&&&.) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
infixr 4 .&&&.

-- | <h1>Solução dos Alunos</h1>
--   
--   <h2>Problema 1</h2>
--   
--   <h3>Dados</h3>
cataExpAr :: (b -> c) -> a -> c
anaExpAr :: (a1 -> b) -> a1 -> ExpAr a2
hyloExpAr :: (b1 -> c) -> (a -> b2) -> a -> c
eval_exp :: Floating a => a -> ExpAr a -> a
optmize_eval :: (Floating a, Eq a) => a -> ExpAr a -> a
sd :: Floating a => ExpAr a -> ExpAr a
ad :: Floating a => a -> ExpAr a -> a

-- | <h3>Definir</h3>
outExpAr :: a
recExpAr :: a
g_eval_exp :: a
clean :: a
gopt :: a
sd_gen :: Floating a => Either () (Either a (Either (BinOp, ((ExpAr a, ExpAr a), (ExpAr a, ExpAr a))) (UnOp, (ExpAr a, ExpAr a)))) -> (ExpAr a, ExpAr a)
ad_gen :: a

-- | <h2>Problema 2</h2>
loop :: a
inic :: a
prj :: a
cat :: Integer -> c

-- | <h2>Problema 3</h2>
--   
--   Spec
--   
--   <pre>
--   <a>calcLine</a> :: <a>NPoint</a> -&gt; (<a>NPoint</a> -&gt; <a>OverTime</a> <a>NPoint</a>)
--   <a>calcLine</a> [] = <a>const</a> <a>nil</a>
--   <a>calcLine</a> (p : x) = <a>curry</a> g p (<a>calcLine</a> x)
--    where
--     g :: (ℚ, <a>NPoint</a> -&gt; <a>OverTime</a> <a>NPoint</a>) -&gt; (<a>NPoint</a> -&gt; <a>OverTime</a> <a>NPoint</a>)
--     g (d, f) l = case l of
--       [] -&gt; <a>nil</a>
--       (x : xs) -&gt; <a>concat</a> . <a>sequenceA</a> [<a>singl</a> . <a>linear1d</a> d x, f xs]
--   </pre>
calcLine :: NPoint -> NPoint -> OverTime NPoint

-- | Spec
--   
--   <pre>
--   <a>deCasteljau</a> :: [<a>NPoint</a>] -&gt; <a>OverTime</a> <a>NPoint</a>
--   <a>deCasteljau</a> [] = <a>nil</a>
--   <a>deCasteljau</a> [p] = <a>const</a> p
--   <a>deCasteljau</a> l = pt -&gt; <a>calcLine</a> (p pt) (q pt) pt
--    where
--     p = <a>deCasteljau</a> (<a>init</a> l)
--     q = <a>deCasteljau</a> (<a>tail</a> l)
--    
--   </pre>
deCasteljau :: [NPoint] -> OverTime NPoint
hyloAlgForm :: a

-- | <h2>Problema 4</h2>
avg :: a -> c
avg_aux :: a
avgLTree :: LTree b -> c
instance GHC.Show.Show Main.BinOp
instance GHC.Classes.Eq Main.BinOp
instance GHC.Show.Show Main.UnOp
instance GHC.Classes.Eq Main.UnOp
instance GHC.Show.Show a => GHC.Show.Show (Main.ExpAr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Main.ExpAr a)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Main.ExpAr a)
instance Test.QuickCheck.Arbitrary.Arbitrary Main.UnOp
instance Test.QuickCheck.Arbitrary.Arbitrary Main.BinOp
