-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Trabalho para Calculo Proposicional da Universidade do Minho
--   
--   Trabalho para Calculo Proposicional da Universidade do Minho
@package cp2021t
@version 0.1.0.0

module Cp
split :: (a -> b) -> (a -> c) -> a -> (b, c)
(><) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
infix 5 ><
(!) :: a -> ()
p1 :: (a, b) -> a
p2 :: (a, b) -> b
i1 :: a -> Either a b
i2 :: b -> Either a b
(-|-) :: (a -> b) -> (c -> d) -> Either a c -> Either b d
infix 4 -|-
cond :: (b -> Bool) -> (b -> c) -> (b -> c) -> b -> c
ap :: (a -> b, a) -> b
expn :: (b -> c) -> (a -> b) -> a -> c
p2p :: (a, a) -> Bool -> a
grd :: (a -> Bool) -> a -> Either a a
swap :: (a, b) -> (b, a)
assocr :: ((a, b), c) -> (a, (b, c))
assocl :: (a, (b, c)) -> ((a, b), c)
undistr :: Either (a, b) (a, c) -> (a, Either b c)
undistl :: Either (b, c) (a, c) -> (Either b a, c)
flatr :: (a, (b, c)) -> (a, b, c)
flatl :: ((a, b), c) -> (a, b, c)
br :: a -> (a, ())
bl :: a -> ((), a)
coswap :: Either a b -> Either b a
coassocr :: Either (Either a b) c -> Either a (Either b c)
coassocl :: Either b (Either a c) -> Either (Either b a) c
distl :: (Either c a, b) -> Either (c, b) (a, b)
distr :: (b, Either c a) -> Either (b, c) (b, a)
class BiFunctor f
bmap :: BiFunctor f => (a -> b) -> (c -> d) -> f a c -> f b d
(.!) :: Monad a => (b -> a c) -> (d -> a b) -> d -> a c
infix 4 .!
mult :: Monad m => m (m b) -> m b
ap' :: Monad m => (a -> m b, m a) -> m b
singl :: a -> [a]
class (Functor f, Monad f) => Strong f
rstr :: Strong f => (f a, b) -> f (a, b)
lstr :: Strong f => (b, f a) -> f (b, a)
dstr :: Strong m => (m a, m b) -> m (a, b)
splitm :: Strong ff => ff (a -> b) -> a -> ff b
bang :: a -> ()
dup :: c -> (c, c)
zero :: Num a => b -> a
one :: Num a => b -> a
nil :: b -> [a]
cons :: (a, [a]) -> [a]
add :: Num c => (c, c) -> c
mul :: Num c => (c, c) -> c
conc :: ([a], [a]) -> [a]
true :: b -> Bool
nothing :: b -> Maybe a
false :: b -> Bool
inMaybe :: Either () a -> Maybe a
class (Functor f) => Unzipable f
unzp :: Unzipable f => f (a, b) -> (f a, f b)
class Functor g => DistL g
lamb :: (DistL g, Monad m) => g (m a) -> m (g a)
aap :: Monad m => m (a -> b) -> m a -> m b
gather :: [a -> b] -> a -> [b]
cozip :: Functor f => Either (f a) (f b) -> f (Either a b)
tot :: (a -> b) -> (a -> Bool) -> a -> Maybe b
instance Cp.DistL []
instance Cp.DistL GHC.Maybe.Maybe
instance Cp.Strong GHC.Types.IO
instance Cp.Strong []
instance Cp.Strong GHC.Maybe.Maybe
instance Cp.BiFunctor Data.Either.Either
instance Cp.BiFunctor (,)

module BTree
data BTree a
Empty :: BTree a
Node :: (a, (BTree a, BTree a)) -> BTree a
inBTree :: Either () (b, (BTree b, BTree b)) -> BTree b
outBTree :: BTree a -> Either () (a, (BTree a, BTree a))
recBTree :: (a -> d) -> Either b1 (b2, (a, a)) -> Either b1 (b2, (d, d))
cataBTree :: (Either () (b, (d, d)) -> d) -> BTree b -> d
anaBTree :: (a -> Either () (b, (a, a))) -> a -> BTree b
hyloBTree :: (Either () (b, (c, c)) -> c) -> (a -> Either () (b, (a, a))) -> a -> c
baseBTree :: (a1 -> b1) -> (a2 -> d) -> Either b2 (a1, (a2, a2)) -> Either b2 (b1, (d, d))
invBTree :: BTree b -> BTree b
countBTree :: BTree a -> Integer
inordt :: BTree a -> [a]
inord :: Either b (a, ([a], [a])) -> [a]
preordt :: BTree a -> [a]
preord :: Either b (a, ([a], [a])) -> [a]
postordt :: BTree a -> [a]
qSort :: Ord a => [a] -> [a]
qsep :: Ord a => [a] -> Either () (a, ([a], [a]))
part :: (a -> Bool) -> [a] -> ([a], [a])
traces :: Eq a => BTree a -> [[a]]
tunion :: Eq a => (a, ([[a]], [[a]])) -> [[a]]
hanoi :: (Bool, Integer) -> [(Integer, Bool)]
present :: Either b (a, ([a], [a])) -> [a]
strategy :: Integral b => (Bool, b) -> Either () ((b, Bool), ((Bool, b), (Bool, b)))
balBTree :: BTree a -> Bool
depthBTree :: BTree a -> Integer
baldepth :: BTree a -> (Bool, Integer)
tnat :: Monoid c => (a -> c) -> Either () (a, (c, c)) -> c
monBTree :: Monoid d => (a -> d) -> BTree a -> d
preordt' :: BTree a -> [a]
countBTree' :: BTree b -> Sum Integer
data Deriv a
Dr :: Bool -> a -> BTree a -> Deriv a
type Zipper a = [Deriv a]
plug :: Zipper a -> BTree a -> BTree a
instance GHC.Show.Show a => GHC.Show.Show (BTree.BTree a)
instance GHC.Base.Functor BTree.BTree

module Nat
inNat :: Either b Integer -> Integer
outNat :: Integral b => b -> Either () b
cataNat :: Integral c => (Either () d -> d) -> c -> d
recNat :: (c -> d) -> Either b c -> Either b d
anaNat :: (c -> Either b c) -> c -> Integer
hyloNat :: (Either () c1 -> c1) -> (c2 -> Either b c2) -> c2 -> c1
for :: Integral c => (b -> b) -> b -> c -> b
somar :: (Integral c, Enum d) => d -> c -> d
multip :: (Integral c, Num d) => d -> c -> d
exp :: (Integral c, Num d) => d -> c -> d
sq :: Integral p => p -> p
sq' :: Integer -> Integer
sq'' :: (Integral c, Num b) => c -> b
fac :: Integer -> Integer
facfor :: Integer -> (Integer, Integer)
idiv :: Integer -> Integer -> Integer
aux :: (Ord c, Num c) => c -> c -> Integer
bSort :: Ord a => [a] -> [a]
while :: (a -> Bool) -> (a -> a) -> a -> a
mfor :: forall t1 m t2. (Monad m, Integral t1) => (t2 -> m t2) -> t2 -> t1 -> m t2

module List
inList :: Either b (a, [a]) -> [a]
outList :: [a] -> Either () (a, [a])
cataList :: (Either () (b, d) -> d) -> [b] -> d
recList :: (c -> d) -> Either b1 (b2, c) -> Either b1 (b2, d)
anaList :: (c -> Either b (a, c)) -> c -> [a]
hyloList :: (Either () (b1, c1) -> c1) -> (c2 -> Either b2 (b1, c2)) -> c2 -> c1
baseList :: (a -> b1) -> (c -> d) -> Either b2 (a, c) -> Either b2 (b1, d)
eval :: Num d => d -> [d] -> d
invl :: [a] -> [a]
look :: Eq a => a -> [(a, b)] -> Maybe b
iSort :: Ord a => [a] -> [a]
take' :: Integer -> [a] -> [a]
fac :: Integer -> Integer
algMul :: Either b (Integer, Integer) -> Integer
nats :: Integer -> Either () (Integer, Integer)
fac' :: Integer -> Integer
sq :: Integer -> Integer
summing :: Either b (Integer, Integer) -> Integer
odds :: Integer -> Either () (Integer, Integer)
sq' :: Integer -> Integer
prefixes :: Eq a => [a] -> [[a]]
suffixes :: [a] -> [[a]]
diff :: Eq a => [a] -> [a] -> [a]
nest :: Eq a => Int -> [a] -> [[a]]
myfoldr :: (a -> b -> b) -> b -> [a] -> b
myfoldl :: (a -> b -> a) -> a -> [b] -> a
nr :: Eq a => [a] -> Bool
ccat :: [a] -> [a] -> [a]
mmap :: Strong m => (a1 -> m a2) -> [a1] -> m [a2]
lam :: Strong m => [m a] -> m [a]
mcataList :: Strong ff => (Either () (b, c) -> ff c) -> [b] -> ff c
dl :: Strong m => Either () (b, m a) -> m (Either () (b, a))
stream :: (t1 -> Maybe (a, t1)) -> (t1 -> t2 -> t1) -> t1 -> [t2] -> [a]
join :: ([a], [b]) -> [Either a b]
sep :: [Either a1 a2] -> ([a1], [a2])

module LTree
data LTree a
Leaf :: a -> LTree a
Fork :: (LTree a, LTree a) -> LTree a
inLTree :: Either a (LTree a, LTree a) -> LTree a
outLTree :: LTree a -> Either a (LTree a, LTree a)
recLTree :: (a -> d) -> Either b (a, a) -> Either b (d, d)
baseLTree :: (a1 -> b) -> (a2 -> d) -> Either a1 (a2, a2) -> Either b (d, d)
cataLTree :: (Either b (d, d) -> d) -> LTree b -> d
anaLTree :: (a1 -> Either a2 (a1, a1)) -> a1 -> LTree a2
hyloLTree :: (Either b (c, c) -> c) -> (a -> Either b (a, a)) -> a -> c
invLTree :: LTree a -> LTree a
countLTree :: LTree b -> Integer
tips :: LTree a -> [a]
dfac :: Integral p => p -> p
dfacd :: Integral b => (b, b) -> Either b ((b, b), (b, b))
dsq' :: Integral p => p -> p
dsq :: Integral p => p -> p
fib :: Integer -> Integer
fibd :: (Ord b, Num b) => b -> Either () (b, b)
mSort :: Ord a => [a] -> [a]
merge :: Ord a => ([a], [a]) -> [a]
lsplit :: [a] -> Either a ([a], [a])
dmap :: (b -> a) -> [b] -> [a]
dmap1 :: (b -> a) -> [b] -> [a]
mu :: LTree (LTree a) -> LTree a
tnat :: Monoid c => (a -> c) -> Either a (c, c) -> c
monLTree :: Monoid d => (a -> d) -> LTree a -> d
tips' :: LTree a -> [a]
countLTree' :: LTree b -> Sum Integer
dlLTree :: Strong f => LTree (f a) -> f (LTree a)
data Deriv a
Dr :: Bool -> LTree a -> Deriv a
type Zipper a = [Deriv a]
plug :: Zipper a -> LTree a -> LTree a
instance GHC.Classes.Eq a => GHC.Classes.Eq (LTree.LTree a)
instance GHC.Show.Show a => GHC.Show.Show (LTree.LTree a)
instance GHC.Base.Functor LTree.LTree
instance GHC.Base.Monad LTree.LTree
instance Cp.Strong LTree.LTree
instance GHC.Base.Applicative LTree.LTree

module Solucoes
data ExpAr a
X :: ExpAr a
N :: a -> ExpAr a
Bin :: BinOp -> ExpAr a -> ExpAr a -> ExpAr a
Un :: UnOp -> ExpAr a -> ExpAr a
data BinOp
Sum :: BinOp
Product :: BinOp
data UnOp
Negate :: UnOp
E :: UnOp

-- | <tt><a>inExpAr</a></tt> ≡ <tt><a>const</a> X <a>∐</a> <a>N</a>
--   <a>∐</a> bin <a>∐</a> (<a>Un</a> <tt>＾</tt>) where bin (op, (a, b)) =
--   <a>Bin</a> op a b</tt>
inExpAr :: (b ∐ (a ∐ (BinExp a ∐ UnExp a))) -> ExpAr a

-- | <tt><a>baseExpAr</a></tt> ≡ <tt>f g h j k l z = f <a>⊕</a> g <a>⊕</a>
--   h <a>×</a> j <a>×</a> k <a>⊕</a> l × z</tt>
baseExpAr :: (a -> b) -> (c -> d) -> (e -> f) -> (g -> h) -> (i -> j) -> (k -> l) -> (m -> n) -> (a ∐ (c ∐ ((e × (g × i)) ∐ (k × m)))) -> b ∐ (d ∐ ((f × (h × j)) ∐ (l × n)))
cataExpAr :: ((() ∐ (c ∐ ((BinOp × (e × e)) ∐ (UnOp × e)))) -> e) -> ExpAr c -> e
anaExpAr :: (a -> b ∐ (c ∐ ((BinOp × (a × a)) ∐ (UnOp × a)))) -> a -> ExpAr c
hyloExpAr :: ((() ∐ (c ∐ ((BinOp × (d × d)) ∐ (UnOp × d)))) -> d) -> (a -> b ∐ (c ∐ ((BinOp × (a × a)) ∐ (UnOp × a)))) -> a -> d
expd :: Floating a => a -> a
eval_exp :: Floating a => a -> ExpAr a -> a
optmize_eval :: (Floating a, Eq a) => a -> ExpAr a -> a
sd :: Floating a => ExpAr a -> ExpAr a
ad :: Floating a => a -> ExpAr a -> a
type a × b = (a, b)
infixr 6 ×

-- | bimap for tuple
(×) :: (a -> b) -> (c -> d) -> (a, c) -> (b, d)
infixr 6 ×

-- | bimap for either
(⊕) :: (a -> b) -> (c -> d) -> (a ∐ c) -> b ∐ d
infixr 4 ⊕
type (∐) = Either
infixr 4 ∐
(∐) :: (a -> c) -> (b -> c) -> (a ∐ b) -> c
infixr 4 ∐

-- | ≡ <tt><a>BinOp</a> <a>×</a> (<a>ExpAr</a> d <a>×</a> <a>ExpAr</a>
--   d)</tt>
type BinExp d = BinOp × ExpAr d × ExpAr d
type UnExp d = UnOp × ExpAr d
type OutExpAr a = () ∐ a ∐ BinExp a ∐ UnExp a
class Injective a b
to :: forall b1 a1. (Injective a b, b1 ~ b, a1 ~ a) => a -> b
outExpAr :: ExpAr a -> OutExpAr a
recExpAr :: (a -> e) -> (b ∐ (c ∐ ((d × (a × a)) ∐ (g × a)))) -> b ∐ (c ∐ ((d × (e × e)) ∐ (g × e)))
g_eval_exp :: Floating c => c -> (b ∐ (c ∐ ((BinOp × (c × c)) ∐ (UnOp × c)))) -> c
clean :: (Eq a, Num a) => ExpAr a -> OutExpAr a
gopt :: Floating a => a -> (() ∐ (a ∐ ((BinOp × (a × a)) ∐ (UnOp × a)))) -> a
type Dup d = d × d
type Bin d = BinOp × d × d
type Un d = UnOp × d
bin_aux :: (t -> t -> t) -> (t -> t -> t) -> (BinOp, Dup (Dup t)) -> Dup t
un_aux :: (t1 -> t2) -> (t2 -> t1 -> t2) -> (t1 -> t2) -> (UnOp, Dup t1) -> Dup t2
sd_gen :: Floating a => (() ∐ (a ∐ (Bin (Dup (ExpAr a)) ∐ Un (Dup (ExpAr a))))) -> Dup (ExpAr a)
ad_gen :: Floating a => a -> (() ∐ (a ∐ ((BinOp, Dup (Dup a)) ∐ (UnOp, Dup a)))) -> Dup a
prop_in_out_idExpAr :: Eq a => ExpAr a -> Bool
prop_out_in_idExpAr :: Eq a => OutExpAr a -> Bool
prop_sum_idr :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_sum_idl :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_product_idr :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_product_idl :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_e_id :: (Floating a, Real a) => a -> Bool
prop_negate_id :: (Floating a, Real a) => a -> Bool
prop_double_negate :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_optimize_respects_semantics :: (Floating a, Real a) => a -> ExpAr a -> Bool
prop_const_rule :: (Real a, Floating a) => a -> Bool
prop_var_rule :: Bool
prop_sum_rule :: (Real a, Floating a) => ExpAr a -> ExpAr a -> Bool
prop_product_rule :: (Real a, Floating a) => ExpAr a -> ExpAr a -> Bool
prop_e_rule :: (Real a, Floating a) => ExpAr a -> Bool
prop_negate_rule :: (Real a, Floating a) => ExpAr a -> Bool
prop_congruent :: (Floating a, Real a) => a -> ExpAr a -> Bool
fib' :: (Integral c, Num b) => c -> b
f' :: (Integral c, Num b) => b -> b -> b -> c -> b
catdef :: Integer -> Integer
oracle :: Num a => [a]
prop_cat :: Integer -> Property
loop :: Integral c => (c, c, c) -> (c, c, c)
inic :: (Num a, Num b, Num c) => (a, b, c)
prj :: (a, b, c) -> a
cat :: (Integral c1, Integral c2) => c1 -> c2
linear1d :: Rational -> Rational -> OverTime Rational
type NPoint = [Rational]
type OverTime a = Float -> a
prop_calcLine_def :: NPoint -> NPoint -> Float -> Bool
prop_bezier_sym :: [[Rational]] -> Gen Bool
type ℚ = Rational
toℚ :: Real a => a -> Rational
fromℚ :: Fractional a => Rational -> a

-- | Spec
--   
--   <pre>
--   <a>calcLine</a> :: <a>NPoint</a> -&gt; (<a>NPoint</a> -&gt; <a>OverTime</a> <a>NPoint</a>)
--   <a>calcLine</a> [] = <a>const</a> <a>nil</a>
--   <a>calcLine</a> (p : x) = <a>curry</a> g p (<a>calcLine</a> x)
--    where
--     g :: (ℚ, <a>NPoint</a> -&gt; <a>OverTime</a> <a>NPoint</a>) -&gt; (<a>NPoint</a> -&gt; <a>OverTime</a> <a>NPoint</a>)
--     g (d, f) l = case l of
--       [] -&gt; <a>nil</a>
--       (x : xs) -&gt; <a>concat</a> . <a>sequenceA</a> [<a>singl</a> . <a>linear1d</a> d x, f xs]
--   </pre>
calcLine :: NPoint -> NPoint -> OverTime NPoint
calc_line' :: [ℚ] -> [ℚ] -> Float -> [ℚ]
myZipWithM :: (a1 -> b -> p -> a2) -> [a1] -> [b] -> p -> [a2]
mySequenceA :: [p -> a] -> p -> [a]
myZipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
myZip :: ([a], [b]) -> [(a, b)]
outZip :: ([a], [b]) -> () ∐ ((a, b), ([a], [b]))
mySequenceA' :: p -> [p -> a] -> [a]

-- | Spec
--   
--   <pre>
--   <a>deCasteljau</a> :: [<a>NPoint</a>] -&gt; <a>OverTime</a> <a>NPoint</a>
--   <a>deCasteljau</a> [] = <a>nil</a>
--   <a>deCasteljau</a> [p] = <a>const</a> p
--   <a>deCasteljau</a> l = pt -&gt; <a>calcLine</a> (p pt) (q pt) pt
--    where
--     p = <a>deCasteljau</a> (<a>init</a> l)
--     q = <a>deCasteljau</a> (<a>tail</a> l)
--    
--   </pre>
deCasteljau :: [NPoint] -> OverTime NPoint
hyloAlgForm :: a
prop_avg :: (Ord b, Fractional b) => [b] -> Property
avg :: Fractional b => [b] -> b
avg_aux :: Fractional b => [b] -> (b, b)
avgLTree :: LTree b -> c
e' :: (Fractional c1, Integral c2) => c1 -> c2 -> c1
bezier2d :: [NPoint] -> OverTime (Float, Float)
data World
World :: [NPoint] -> Float -> World
[points] :: World -> [NPoint]
[time] :: World -> Float
initW :: World
tick :: Float -> World -> World
actions :: Event -> World -> World
scaleTime :: World -> Float
bezier2dAtTime :: World -> (Float, Float)
bezier2dAt :: World -> OverTime (Float, Float)
thicCirc :: Picture
ps :: [Float]
picture :: World -> Picture
animateBezier :: Float -> [NPoint] -> Picture
runBezier :: IO ()
runBezierSym :: IO ()
main :: IO ()
run :: IO ExitCode
(.=?=.) :: Real a => a -> a -> Bool
infixr 5 .=?=.
(.==>.) :: Testable prop => (a -> Bool) -> (a -> prop) -> a -> Property
infixr 0 .==>.
(.<==>.) :: (a -> Bool) -> (a -> Bool) -> a -> Property
infixr 0 .<==>.
(.==.) :: Eq b => (a -> b) -> (a -> b) -> a -> Bool
infixr 4 .==.
(.<=.) :: Ord b => (a -> b) -> (a -> b) -> a -> Bool
infixr 4 .<=.
(.&&&.) :: (a -> Bool) -> (a -> Bool) -> a -> Bool
infixr 4 .&&&.
instance GHC.Show.Show Solucoes.BinOp
instance GHC.Classes.Eq Solucoes.BinOp
instance GHC.Show.Show Solucoes.UnOp
instance GHC.Classes.Eq Solucoes.UnOp
instance GHC.Show.Show a => GHC.Show.Show (Solucoes.ExpAr a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Solucoes.ExpAr a)
instance Solucoes.Injective (Solucoes.ExpAr a) (Solucoes.OutExpAr a)
instance GHC.Num.Num c => Solucoes.Injective Solucoes.BinOp ((c, c) -> c)
instance GHC.Float.Floating c => Solucoes.Injective Solucoes.UnOp (c -> c)
instance Test.QuickCheck.Arbitrary.Arbitrary a => Test.QuickCheck.Arbitrary.Arbitrary (Solucoes.ExpAr a)
instance Test.QuickCheck.Arbitrary.Arbitrary Solucoes.UnOp
instance Test.QuickCheck.Arbitrary.Arbitrary Solucoes.BinOp
