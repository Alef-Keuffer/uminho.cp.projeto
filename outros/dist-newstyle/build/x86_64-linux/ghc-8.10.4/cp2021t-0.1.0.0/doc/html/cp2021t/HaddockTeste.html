<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title>HaddockTeste</title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption">cp2021t-0.1.0.0: Trabalho para Calculo Proposicional da Universidade do Minho</span><ul class="links" id="page-menu"><li><a href="src/HaddockTeste.html">Source</a></li><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="module-header"><table class="info"><tr><th>Safe Haskell</th><td>None</td></tr><tr><th>Language</th><td>Haskell2010</td></tr></table><p class="caption">HaddockTeste</p></div><div id="table-of-contents"><div id="contents-list"><p class="caption" onclick="window.scrollTo(0,0)">Contents</p><ul><li><a href="#g:1">Pre&#226;mbulo</a></li><li><a href="#g:2">Documenta&#231;&#227;o</a></li><li><a href="#g:3">Como realizar o trabalho</a><ul><li><a href="#g:4">Stack</a></li></ul></li><li><a href="#g:5">Problemas</a><ul><li><a href="#g:6">Problema 1</a></li></ul></li></ul></div></div><div id="synopsis"><details id="syn"><summary>Synopsis</summary><ul class="details-toggle" data-details-id="syn"></ul></details></div><div id="interface"><a href="#g:1" id="g:1"><h1>Pre&#226;mbulo</h1></a><div class="doc"><p><a href="https://haslab.github.io/CP/">C&#225;lculo de Programas</a> tem como objectivo principal ensinar
a programa&#231;&#227;o de computadores como uma disciplina cient&#237;fica. Para isso
parte-se de um repert&#243;rio de <em>combinadores</em> que formam uma &#225;lgebra da
programa&#231;&#227;o (conjunto de leis universais e seus corol&#225;rios) e usam-se esses
combinadores para construir programas <em>composicionalmente</em>, isto &#233;,
agregando programas j&#225; existentes.</p><p>Na sequ&#234;ncia pedag&#243;gica dos planos de estudo dos dois cursos que t&#234;m
esta disciplina, opta-se pela aplica&#231;&#227;o deste m&#233;todo &#224; programa&#231;&#227;o
em <a href="http://www.haskell.org">Haskell</a> (sem preju&#237;zo da sua aplica&#231;&#227;o a outras linguagens
funcionais). Assim, o presente trabalho pr&#225;tico coloca os
alunos perante problemas concretos que dever&#227;o ser implementados em <a href="http://www.haskell.org">Haskell</a>.  H&#225; ainda um outro objectivo: o de ensinar a documentar
programas, a valid&#225;-los e a produzir textos t&#233;cnico-cient&#237;ficos de
qualidade.</p></div><a href="#g:2" id="g:2"><h1>Documenta&#231;&#227;o</h1></a><div class="doc"><p>Para cumprir de forma integrada os objectivos
enunciados acima vamos recorrer a uma t&#233;cnica de programa&#231;&#227;o dita
&quot;<a href="http://www.literateprogramming.com">liter&#225;ria</a>&quot; <a href="#1">[1</a>], cujo princ&#237;pio base &#233; o seguinte:</p><p>&quot;Um programa e a sua documenta&#231;&#227;o devem coincidir.&quot;</p><p>Por outras palavras, o c&#243;digo fonte e a documenta&#231;&#227;o de um
programa dever&#227;o estar no mesmo ficheiro.</p><p>O ficheiro <code>cp2021t.pdf</code> que est&#225; a ler &#233; j&#225; um exemplo de
[programa&#231;&#227;o liter&#225;ria](http://www.literateprogramming.com): foi gerado a partir do texto fonte
<code>cp2021t.lhs</code> que encontrar&#225; no <a href="https://haslab.github.io/CP/Material/">Material Pedag&#243;gico</a> desta disciplina descompactando o ficheiro
<code>cp2021t.zip</code> e executando:</p><pre>  $ <code>lhs2TeX</code> cp2021t.lhs &gt; cp2021t.tex
  $ pdflatex cp2021t
</pre><p>em que <a href="https://hackage.haskell.org/package/lhs2tex"><code>lhs2tex</code></a> &#233;
um pre-processador que faz &quot;pretty printing&quot;
de c&#243;digo Haskell em <a href="http://www.tug.org/index.html"><span class="mathjax">\(\ \LaTeX\)</span></a> e que deve desde j&#225; instalar executando</p><pre>  $ <code>cabal</code> install <code>lhs2tex</code> --lib
</pre><p>Por outro lado, o mesmo ficheiro <code>cp2021t.lhs</code> &#233; execut&#225;vel e cont&#233;m
o &quot;kit&quot; b&#225;sico, escrito em <a href="http://www.haskell.org">Haskell</a>, para realizar o trabalho. Basta executar</p><pre>  $ ghci cp2021t.lhs
</pre><p>Abra o ficheiro <strong><em>cp2021t.lhs</em></strong> no seu editor de texto preferido
e verifique que assim &#233;: todo o texto que se encontra dentro do ambiente</p><pre>\begin{code}
...
\end{code}
</pre><p>&#233; seleccionado pelo <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html">GHCi</a> para ser executado.</p></div><a href="#g:3" id="g:3"><h1>Como realizar o trabalho</h1></a><div class="doc"><p>Este trabalho te&#243;rico-pr&#225;tico deve ser realizado por grupos de 3 (ou 4) alunos.
Os detalhes da avalia&#231;&#227;o (datas para submiss&#227;o do relat&#243;rio e sua defesa
oral) s&#227;o os que forem publicados na <a href="https://haslab.github.io/CP/">p&#225;gina da disciplina</a> na <em>internet</em>.</p><p>Recomenda-se uma abordagem participativa dos membros do grupo
de trabalho por forma a poderem responder &#224;s quest&#245;es que ser&#227;o colocadas
na <em>defesa oral</em> do relat&#243;rio.</p><p>Em que consiste, ent&#227;o, o <em>relat&#243;rio</em> a que se refere o par&#225;grafo anterior?
&#201; a edi&#231;&#227;o do texto que est&#225; a ser lido, preenchendo o anexo ref{sec:resolucao}
com as respostas. O relat&#243;rio dever&#225; conter ainda a identifica&#231;&#227;o dos membros
do grupo de trabalho, no local respectivo da folha de rosto.</p><p>Para gerar o PDF integral do relat&#243;rio deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com <a href="http://www.bibtex.org/"><span class="mathjax">\(\textrm{Bib}\TeX\)</span></a>) e o &#237;ndice remissivo (com <a href="https://www.ctan.org/pkg/makeindex"><code>makeindex</code></a>),</p><pre>  $ bibtex cp2021t.aux
  $ makeindex cp2021t.idx
</pre><p>e recompilar o texto como acima se indicou. Dever-se-&#225; ainda instalar
o utilit&#225;rio <a href="https://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a>,
que ajuda a validar programas em <a href="http://www.haskell.org">Haskell</a> e a biblioteca <a href="https://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss.html">Gloss</a> para
gera&#231;&#227;o de gr&#225;ficos 2D:</p><pre>  $ <code>cabal</code> install <code>QuickCheck</code> <code>gloss</code> --lib
</pre><p>Para testar uma propriedade <a href="https://wiki.haskell.org/Introduction_to_QuickCheck1">QuickCheck</a> <em>prop</em>, basta invoc&#225;-la com o comando:</p><pre>    &gt; <code>quickCheck</code> prop
    +++ OK, passed 100 tests.
</pre><p>Pode-se ainda controlar o n&#250;mero de casos de teste e sua complexidade,
como o seguinte exemplo mostra:</p><pre>  &gt; <code>quickCheckWith</code> stdArgs { maxSuccess = 200, maxSize = 10 } prop
  +++ OK, passed 200 tests.
</pre><p>Qualquer programador tem, na vida real, de ler e analisar (muito!) c&#243;digo
escrito por outros. No anexo {ref: C} disponibiliza-se algum
c&#243;digo <a href="http://www.haskell.org">Haskell</a> relativo aos problemas que se seguem. Esse anexo dever&#225;
ser consultado e analisado &#224; medida que isso for necess&#225;rio.</p></div><a href="#g:4" id="g:4"><h2>Stack</h2></a><div class="doc"><p>O <a href="https://docs.haskellstack.org/en/stable/README/">Stack</a> &#233; um programa &#250;til para criar, gerir e manter projetos em <a href="http://www.haskell.org">Haskell</a>.
Um projeto criado com o Stack possui uma estrutura de pastas muito espec&#237;fica:</p><ul><li>Os m&#243;dulos auxiliares encontram-se na pasta emph{src}.</li><li>O m&#243;dulos principal encontra-se na pasta emph{app}.</li><li>A lista de dep&#234;ndencias externas encontra-se no ficheiro emph{package.yaml}.</li></ul><p>Pode aceder ao <a href="https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html">GHCi</a> utilizando o comando:</p><pre>stack ghci</pre><p>Garanta que se encontra na pasta mais externa <em>do projeto</em>.
A primeira vez que correr este comando as dep&#234;ndencias externas ser&#227;o instaladas automaticamente.</p><p>Para gerar o PDF, garanta que se encontra na diretoria <strong>app</strong>.</p></div><a href="#g:5" id="g:5"><h1>Problemas</h1></a><a href="#g:6" id="g:6"><h2>Problema 1</h2></a><div class="doc"><p>Os <em>tipos de dados alg&#233;bricos</em> estudados ao longo desta disciplina oferecem
uma grande capacidade expressiva ao programador. Gra&#231;as &#224; sua flexibilidade,
torna-se trivial implementar [DSL]s(https:/<em>www.researchgate.net</em>publication/254462947_Experience_report_A_do-it-yourself_high-assurance_compiler)
e at&#233; mesmo <a href="http://www.cse.chalmers.se/~ulfn/papers/thesis.pdf">linguagens de programa&#231;&#227;o</a>.</p><p>Paralelamente, um t&#243;pico bastante estudado no &#226;mbito de <strong>DL</strong>
&#233; a deriva&#231;&#227;o autom&#225;tica de express&#245;es matem&#225;ticas, por exemplo, de derivadas.
Duas t&#233;cnicas que podem ser utilizadas para o c&#225;lculo de derivadas s&#227;o:</p><ul><li><em>Symbolic differentiation</em></li><li><em>Automatic differentiation</em></li></ul><p><em>Symbolic differentiation</em> consiste na aplica&#231;&#227;o sucessiva de transforma&#231;&#245;es
(leia-se: fun&#231;&#245;es) que sejam congruentes com as regras de deriva&#231;&#227;o. O resultado
final ser&#225; a express&#227;o da derivada.</p><p>O leitor atento poder&#225; notar um problema desta t&#233;cnica: a express&#227;o
inicial pode crescer de forma descontrolada, levando a um c&#225;lculo pouco eficiente.
<em>Automatic differentiation</em> tenta resolver este problema,
calculando <strong>o valor</strong> da derivada da express&#227;o em todos os passos.
Para tal, &#233; necess&#225;rio calcular o valor da express&#227;o <strong>e</strong> o valor da sua derivada.</p><p>Vamos de seguida definir uma linguagem de express&#245;es matem&#225;ticas simples e
implementar as duas t&#233;cnicas de deriva&#231;&#227;o autom&#225;tica.
Para isso, seja dado o seguinte tipo de dados,</p><pre>data <code><a href="Solucoes.html#t:ExpAr" title="Solucoes">ExpAr</a></code> a = <code><a href="Solucoes.html#v:X" title="Solucoes">X</a></code>
           | <code><a href="Solucoes.html#v:N" title="Solucoes">N</a></code> a
           | <code><a href="Solucoes.html#t:Bin" title="Solucoes">Bin</a></code> <code><a href="Solucoes.html#t:BinOp" title="Solucoes">BinOp</a></code> (<code><a href="Solucoes.html#t:ExpAr" title="Solucoes">ExpAr</a></code> a) (<code><a href="Solucoes.html#t:ExpAr" title="Solucoes">ExpAr</a></code> a)
           | <code><a href="Solucoes.html#t:Un" title="Solucoes">Un</a></code> <code><a href="Solucoes.html#t:UnOp" title="Solucoes">UnOp</a></code> (<code><a href="Solucoes.html#t:ExpAr" title="Solucoes">ExpAr</a></code> a)
           deriving (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code>, <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Text-Show.html#t:Show" title="Text.Show">Show</a></code>)
</pre><p>onde <code><a href="Solucoes.html#t:BinOp" title="Solucoes">BinOp</a></code> e <code><a href="Solucoes.html#t:UnOp" title="Solucoes">UnOp</a></code> representam opera&#231;&#245;es bin&#225;rias e un&#225;rias, respectivamente:</p><p>data <code><a href="Solucoes.html#t:BinOp" title="Solucoes">BinOp</a></code> = <code><a href="Solucoes.html#v:Sum" title="Solucoes">Sum</a></code>
           | <code><a href="Solucoes.html#v:Product" title="Solucoes">Product</a></code>
           deriving (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code>, <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Text-Show.html#t:Show" title="Text.Show">Show</a></code>)</p><p>data <code><a href="Solucoes.html#t:UnOp" title="Solucoes">UnOp</a></code> = <code><a href="Solucoes.html#v:Negate" title="Solucoes">Negate</a></code>
          | <code><a href="Solucoes.html#v:E" title="Solucoes">E</a></code>
          deriving (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code>, <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Text-Show.html#t:Show" title="Text.Show">Show</a></code>)</p><p>O construtor <code><a href="Solucoes.html#v:E" title="Solucoes">E</a></code> simboliza o exponencial de base <span class="mathjax">\(e\)</span>.</p><p>Assim, cada express&#227;o pode ser uma vari&#225;vel, um n&#250;mero, uma opera&#231;&#227;o bin&#225;ria
aplicada &#224;s devidas express&#245;es, ou uma opera&#231;&#227;o un&#225;ria aplicada a uma express&#227;o.</p><p>Por exemplo,</p><pre><code><a href="Solucoes.html#t:Bin" title="Solucoes">Bin</a></code> <code><a href="Solucoes.html#v:Sum" title="Solucoes">Sum</a></code> <code><a href="Solucoes.html#v:X" title="Solucoes">X</a></code> (<code><a href="Solucoes.html#v:N" title="Solucoes">N</a></code> 10)
</pre><p>designa <span class="mathjax">\(x+10\)</span> na nota&#231;&#227;o matem&#225;tica habitual.</p><p>A defini&#231;&#227;o das fun&#231;&#245;es <code><a href="Solucoes.html#v:inExpAr" title="Solucoes">inExpAr</a></code> e <code><a href="Solucoes.html#v:baseExpAr" title="Solucoes">baseExpAr</a></code> para este tipo &#233; a seguinte:</p><pre><code><a href="Solucoes.html#v:inExpAr" title="Solucoes">inExpAr</a></code> = <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Either.html#v:either" title="Data.Either">either</a></code> (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Function.html#v:const" title="Data.Function">const</a></code> <code><a href="Solucoes.html#v:X" title="Solucoes">X</a></code>) num_ops where
  num_ops = <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Either.html#v:either" title="Data.Either">either</a></code> <code><a href="Solucoes.html#v:N" title="Solucoes">N</a></code> ops
  ops     = <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Either.html#v:either" title="Data.Either">either</a></code> bin (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Tuple.html#v:uncurry" title="Data.Tuple">uncurry</a></code> <code><a href="Solucoes.html#t:Un" title="Solucoes">Un</a></code>)
  bin(op, (a, b)) = <code><a href="Solucoes.html#t:Bin" title="Solucoes">Bin</a></code> op a b

<code><a href="Solucoes.html#v:baseExpAr" title="Solucoes">baseExpAr</a></code> f g h j k l z = f <code><a href="Cp.html#v:-45--124--45-" title="Cp">-|-</a></code> (g <code><a href="Cp.html#v:-45--124--45-" title="Cp">-|-</a></code> (h <code>&gt;&lt;</code> (j <code>&gt;&lt;</code> k) <code><a href="Cp.html#v:-45--124--45-" title="Cp">-|-</a></code> l <code>&gt;&lt;</code> z))
</pre><p>Defina as fun&#231;&#245;es <code><a href="Solucoes.html#v:outExpAr" title="Solucoes">outExpAr</a></code> e <code><a href="Solucoes.html#v:recExpAr" title="Solucoes">recExpAr</a></code>,
e teste as propriedades que se seguem.</p><p>#. Propriedade
    <code><a href="Solucoes.html#v:inExpAr" title="Solucoes">inExpAr</a></code> e <code><a href="Solucoes.html#v:outExpAr" title="Solucoes">outExpAr</a></code> s&#227;o testemunhas de um isomorfismo,
    isto &#233;, <code><a href="Solucoes.html#v:inExpAr" title="Solucoes">inExpAr</a></code> &#8901; <code><a href="Solucoes.html#v:outExpAr" title="Solucoes">outExpAr</a></code> = <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Function.html#v:id" title="Data.Function">id</a></code> e <code><a href="Solucoes.html#v:outExpAr" title="Solucoes">outExpAr</a></code> &#8901; <code>idExpAr</code> = <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Function.html#v:id" title="Data.Function">id</a></code>:</p><pre><code><a href="Solucoes.html#v:prop_in_out_idExpAr" title="Solucoes">prop_in_out_idExpAr</a></code> :: (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code> a) =&gt; <code><a href="Solucoes.html#t:ExpAr" title="Solucoes">ExpAr</a></code> a -&gt; <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>
<code><a href="Solucoes.html#v:prop_in_out_idExpAr" title="Solucoes">prop_in_out_idExpAr</a></code> = <code><a href="Solucoes.html#v:inExpAr" title="Solucoes">inExpAr</a></code> &#8901; <code><a href="Solucoes.html#v:outExpAr" title="Solucoes">outExpAr</a></code> .==. <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Function.html#v:id" title="Data.Function">id</a></code>

<code><a href="Solucoes.html#v:prop_out_in_idExpAr" title="Solucoes">prop_out_in_idExpAr</a></code> :: (<code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Eq.html#t:Eq" title="Data.Eq">Eq</a></code> a) =&gt; <code><a href="Solucoes.html#t:OutExpAr" title="Solucoes">OutExpAr</a></code> a <code>-&gt;</code> <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Bool.html#t:Bool" title="Data.Bool">Bool</a></code>
<code><a href="Solucoes.html#v:prop_out_in_idExpAr" title="Solucoes">prop_out_in_idExpAr</a></code> = <code><a href="Solucoes.html#v:outExpAr" title="Solucoes">outExpAr</a></code> &#8901; <code><a href="Solucoes.html#v:inExpAr" title="Solucoes">inExpAr</a></code> .==. <code><a href="file:///home/alef/.ghcup/ghc/8.10.4/share/doc/ghc-8.10.4/html/libraries/base-4.14.1.0/Data-Function.html#v:id" title="Data.Function">id</a></code>
</pre><dl><dt><a id="1"></a></dt><dd>D.E. Knuth. Literate Programming. CSLI Lecture Notes Number 27. Stanford University Center for the Study of Language and Information, Stanford, CA, USA, 1992.</dd></dl></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.24.0</p></div></body></html>