<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css" /><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# OPTIONS_GHC -XNPlusKPatterns #-}</span><span>
</span><span id="line-2"></span><span class="hs-pragma">{-# LANGUAGE GeneralizedNewtypeDeriving, DeriveDataTypeable, FlexibleInstances #-}</span><span>
</span><span id="line-3"></span><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">HaddockTeste</span><span> </span><span class="hs-keyword">where</span><span>
</span><span id="line-4"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Solucoes.html"><span class="hs-identifier">Solucoes</span></a></span><span>
</span><span id="line-5"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><a href="Cp.html"><span class="hs-identifier">Cp</span></a></span><span>
</span><span id="line-6"></span><span class="hs-keyword">import</span><span> </span><span class="annot"><span class="hs-identifier">Test.QuickCheck</span></span><span>
</span><span id="line-7"></span><span>
</span><span id="line-8"></span><span class="hs-comment">-- * Pre&#226;mbulo</span><span>
</span><span id="line-9"></span><span>
</span><span id="line-10"></span><span class="hs-comment">{- $doc
[C&#225;lculo de Programas](https://haslab.github.io/CP/) tem como objectivo principal ensinar
a programa&#231;&#227;o de computadores como uma disciplina cient&#237;fica. Para isso
parte-se de um repert&#243;rio de /combinadores/ que formam uma &#225;lgebra da
programa&#231;&#227;o (conjunto de leis universais e seus corol&#225;rios) e usam-se esses
combinadores para construir programas /composicionalmente/, isto &#233;,
agregando programas j&#225; existentes.

Na sequ&#234;ncia pedag&#243;gica dos planos de estudo dos dois cursos que t&#234;m
esta disciplina, opta-se pela aplica&#231;&#227;o deste m&#233;todo &#224; programa&#231;&#227;o
em [Haskell](http://www.haskell.org) (sem preju&#237;zo da sua aplica&#231;&#227;o a outras linguagens
funcionais). Assim, o presente trabalho pr&#225;tico coloca os
alunos perante problemas concretos que dever&#227;o ser implementados em [Haskell](http://www.haskell.org).  H&#225; ainda um outro objectivo: o de ensinar a documentar
programas, a valid&#225;-los e a produzir textos t&#233;cnico-cient&#237;ficos de
qualidade.
-}</span><span>
</span><span id="line-26"></span><span>
</span><span id="line-27"></span><span class="hs-comment">-- * Documenta&#231;&#227;o</span><span>
</span><span id="line-28"></span><span>
</span><span id="line-29"></span><span class="hs-comment">{- $doc

Para cumprir de forma integrada os objectivos
enunciados acima vamos recorrer a uma t&#233;cnica de programa&#231;&#227;o dita
&quot;[liter&#225;ria](http://www.literateprogramming.com)&quot; [[1](#1)], cujo princ&#237;pio base &#233; o seguinte:

&quot;Um programa e a sua documenta&#231;&#227;o devem coincidir.&quot;

Por outras palavras, o c&#243;digo fonte e a documenta&#231;&#227;o de um
programa dever&#227;o estar no mesmo ficheiro.

O ficheiro @cp2021t.pdf@ que est&#225; a ler &#233; j&#225; um exemplo de
[programa&#231;&#227;o liter&#225;ria](http://www.literateprogramming.com): foi gerado a partir do texto fonte
@cp2021t.lhs@ que encontrar&#225; no [Material Pedag&#243;gico](https://haslab.github.io/CP/Material/) desta disciplina descompactando o ficheiro
@cp2021t.zip@ e executando:

@
  $ 'lhs2TeX' cp2021t.lhs &gt; cp2021t.tex
  $ pdflatex cp2021t
@

em que [@lhs2tex@](https://hackage.haskell.org/package/lhs2tex) &#233;
um pre-processador que faz &quot;pretty printing&quot;
de c&#243;digo Haskell em [\(\ \LaTeX\)](http://www.tug.org/index.html) e que deve desde j&#225; instalar executando

@
  $ 'cabal' install 'lhs2tex' --lib
@

Por outro lado, o mesmo ficheiro @cp2021t.lhs@ &#233; execut&#225;vel e cont&#233;m
o &quot;kit&quot; b&#225;sico, escrito em [Haskell](http://www.haskell.org), para realizar o trabalho. Basta executar

@
  $ ghci cp2021t.lhs
@

Abra o ficheiro __/cp2021t.lhs/__ no seu editor de texto preferido
e verifique que assim &#233;: todo o texto que se encontra dentro do ambiente

@
\\begin{code}
...
\\end{code}
@

&#233; seleccionado pelo [GHCi](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html) para ser executado.

-}</span><span>
</span><span id="line-77"></span><span>
</span><span id="line-78"></span><span class="hs-comment">-- * Como realizar o trabalho</span><span>
</span><span id="line-79"></span><span>
</span><span id="line-80"></span><span class="hs-comment">{- $doc

Este trabalho te&#243;rico-pr&#225;tico deve ser realizado por grupos de 3 (ou 4) alunos.
Os detalhes da avalia&#231;&#227;o (datas para submiss&#227;o do relat&#243;rio e sua defesa
oral) s&#227;o os que forem publicados na [p&#225;gina da disciplina](https://haslab.github.io/CP/) na /internet/.

Recomenda-se uma abordagem participativa dos membros do grupo
de trabalho por forma a poderem responder &#224;s quest&#245;es que ser&#227;o colocadas
na /defesa oral/ do relat&#243;rio.

Em que consiste, ent&#227;o, o /relat&#243;rio/ a que se refere o par&#225;grafo anterior?
&#201; a edi&#231;&#227;o do texto que est&#225; a ser lido, preenchendo o anexo \ref{sec:resolucao}
com as respostas. O relat&#243;rio dever&#225; conter ainda a identifica&#231;&#227;o dos membros
do grupo de trabalho, no local respectivo da folha de rosto.

Para gerar o PDF integral do relat&#243;rio deve-se ainda correr os comando seguintes,
que actualizam a bibliografia (com [\(\textrm{Bib}\TeX\)](http://www.bibtex.org/)) e o &#237;ndice remissivo (com [@makeindex@](https://www.ctan.org/pkg/makeindex)),

@
  $ bibtex cp2021t.aux
  $ makeindex cp2021t.idx
@

e recompilar o texto como acima se indicou. Dever-se-&#225; ainda instalar
o utilit&#225;rio [QuickCheck](https://wiki.haskell.org/Introduction_to_QuickCheck1),
que ajuda a validar programas em [Haskell](http://www.haskell.org) e a biblioteca [Gloss](https://hackage.haskell.org/package/gloss-1.13.1.1/docs/Graphics-Gloss.html) para
gera&#231;&#227;o de gr&#225;ficos 2D:

@
  $ 'cabal' install 'QuickCheck' 'gloss' --lib
@

Para testar uma propriedade [QuickCheck](https://wiki.haskell.org/Introduction_to_QuickCheck1) /prop/, basta invoc&#225;-la com o comando:

@
    &gt; 'quickCheck' prop
    +++ OK, passed 100 tests.
@

Pode-se ainda controlar o n&#250;mero de casos de teste e sua complexidade,
como o seguinte exemplo mostra:

@
  &gt; 'quickCheckWith' stdArgs { maxSuccess = 200, maxSize = 10 } prop
  +++ OK, passed 200 tests.
@

Qualquer programador tem, na vida real, de ler e analisar (muito!) c&#243;digo
escrito por outros. No anexo {ref: C} disponibiliza-se algum
c&#243;digo [Haskell](http://www.haskell.org) relativo aos problemas que se seguem. Esse anexo dever&#225;
ser consultado e analisado &#224; medida que isso for necess&#225;rio.
-}</span><span>
</span><span id="line-132"></span><span>
</span><span id="line-133"></span><span class="hs-comment">-- ** Stack</span><span>
</span><span id="line-134"></span><span>
</span><span id="line-135"></span><span class="hs-comment">{- $doc
O [Stack](https://docs.haskellstack.org/en/stable/README/) &#233; um programa &#250;til para criar, gerir e manter projetos em [Haskell](http://www.haskell.org).
Um projeto criado com o Stack possui uma estrutura de pastas muito espec&#237;fica:

* Os m&#243;dulos auxiliares encontram-se na pasta \emph{src}.
* O m&#243;dulos principal encontra-se na pasta \emph{app}.
* A lista de dep&#234;ndencias externas encontra-se no ficheiro \emph{package.yaml}.

Pode aceder ao [GHCi](https://downloads.haskell.org/~ghc/latest/docs/html/users_guide/ghci.html) utilizando o comando:

@stack ghci@

Garanta que se encontra na pasta mais externa /do projeto/.
A primeira vez que correr este comando as dep&#234;ndencias externas ser&#227;o instaladas automaticamente.

Para gerar o PDF, garanta que se encontra na diretoria __app__.
-}</span><span>
</span><span id="line-152"></span><span>
</span><span id="line-153"></span><span class="hs-comment">-- * Problemas</span><span>
</span><span id="line-154"></span><span>
</span><span id="line-155"></span><span class="hs-comment">-- ** Problema 1</span><span>
</span><span id="line-156"></span><span>
</span><span id="line-157"></span><span class="hs-comment">{- $doc2

Os /tipos de dados alg&#233;bricos/ estudados ao longo desta disciplina oferecem
uma grande capacidade expressiva ao programador. Gra&#231;as &#224; sua flexibilidade,
torna-se trivial implementar [DSL]s(https://www.researchgate.net/publication/254462947_Experience_report_A_do-it-yourself_high-assurance_compiler)
e at&#233; mesmo [linguagens de programa&#231;&#227;o](http://www.cse.chalmers.se/~ulfn/papers/thesis.pdf).

Paralelamente, um t&#243;pico bastante estudado no &#226;mbito de __DL__
&#233; a deriva&#231;&#227;o autom&#225;tica de express&#245;es matem&#225;ticas, por exemplo, de derivadas.
Duas t&#233;cnicas que podem ser utilizadas para o c&#225;lculo de derivadas s&#227;o:

* /Symbolic differentiation/
* /Automatic differentiation/

/Symbolic differentiation/ consiste na aplica&#231;&#227;o sucessiva de transforma&#231;&#245;es
(leia-se: fun&#231;&#245;es) que sejam congruentes com as regras de deriva&#231;&#227;o. O resultado
final ser&#225; a express&#227;o da derivada.

O leitor atento poder&#225; notar um problema desta t&#233;cnica: a express&#227;o
inicial pode crescer de forma descontrolada, levando a um c&#225;lculo pouco eficiente.
/Automatic differentiation/ tenta resolver este problema,
calculando __o valor__ da derivada da express&#227;o em todos os passos.
Para tal, &#233; necess&#225;rio calcular o valor da express&#227;o __e__ o valor da sua derivada.

Vamos de seguida definir uma linguagem de express&#245;es matem&#225;ticas simples e
implementar as duas t&#233;cnicas de deriva&#231;&#227;o autom&#225;tica.
Para isso, seja dado o seguinte tipo de dados,

@
data 'ExpAr' a = 'X'
           | 'N' a
           | 'Bin' 'BinOp' ('ExpAr' a) ('ExpAr' a)
           | 'Un' 'UnOp' ('ExpAr' a)
           deriving ('Eq', 'Show')
@

onde 'BinOp' e 'UnOp' representam opera&#231;&#245;es bin&#225;rias e un&#225;rias, respectivamente:

data 'BinOp' = 'Sum'
           | 'Product'
           deriving ('Eq', 'Show')

data 'UnOp' = 'Negate'
          | 'E'
          deriving ('Eq', 'Show')

O construtor 'E' simboliza o exponencial de base \(e\).

Assim, cada express&#227;o pode ser uma vari&#225;vel, um n&#250;mero, uma opera&#231;&#227;o bin&#225;ria
aplicada &#224;s devidas express&#245;es, ou uma opera&#231;&#227;o un&#225;ria aplicada a uma express&#227;o.

Por exemplo,

@
'Bin' 'Sum' 'X' ('N' 10)
@

designa \(x+10\) na nota&#231;&#227;o matem&#225;tica habitual.

A defini&#231;&#227;o das fun&#231;&#245;es 'inExpAr' e 'baseExpAr' para este tipo &#233; a seguinte:

@
'inExpAr' = 'either' ('const' 'X') num_ops where
  num_ops = 'either' 'N' ops
  ops     = 'either' bin ('uncurry' 'Un')
  bin(op, (a, b)) = 'Bin' op a b

'baseExpAr' f g h j k l z = f '-|-' (g '-|-' (h '&gt;&lt;' (j '&gt;&lt;' k) '-|-' l '&gt;&lt;' z))
@

Defina as fun&#231;&#245;es 'outExpAr' e 'recExpAr',
e teste as propriedades que se seguem.

#. Propriedade
    'inExpAr' e 'outExpAr' s&#227;o testemunhas de um isomorfismo,
    isto &#233;, 'inExpAr' &#8901; 'outExpAr' = 'id' e 'outExpAr' &#8901; 'idExpAr' = 'id':

@
'prop_in_out_idExpAr' :: ('Eq' a) =&gt; 'ExpAr' a -&gt; 'Bool'
'prop_in_out_idExpAr' = 'inExpAr' &#8901; 'outExpAr' .==. 'id'

'prop_out_in_idExpAr' :: ('Eq' a) =&gt; 'OutExpAr' a '-&gt;' 'Bool'
'prop_out_in_idExpAr' = 'outExpAr' &#8901; 'inExpAr' .==. 'id'
@

[#1#]: D.E. Knuth. Literate Programming. CSLI Lecture Notes Number 27. Stanford University Center for the Study of Language and Information, Stanford, CA, USA, 1992.
-}</span><span>
</span><span id="line-244"></span></pre></body></html>